package agent

import (
	"context"
	"encoding/json"
	"errors"
	"sync"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap/zaptest"

	"github.com/xkilldash9x/scalpel-cli/api/schemas"
	"github.com/xkilldash9x/scalpel-cli/internal/config"
)

// -- Test Setup Helper --

// setupLLMMind initializes the LLMMind and its dependencies for testing.
func setupLLMMind(t *testing.T) (*LLMMind, *MockLLMClient, *MockGraphStore, *CognitiveBus) {
	t.Helper()
	logger := zaptest.NewLogger(t)
	mockLLM := new(MockLLMClient)
	mockKG := new(MockGraphStore)
	// Use a real CognitiveBus to properly test the integration of the OODA loop.
	bus := NewCognitiveBus(logger, 50)

	// A default configuration for our tests.
	cfg := config.AgentConfig{
		LLM: config.LLMRouterConfig{
			DefaultPowerfulModel: "test-model",
			Models:               map[string]config.LLMModelConfig{"test-model": {Model: "test-model"}},
		},
	}

	mind := NewLLMMind(logger, mockLLM, cfg, mockKG, bus)

	// Make sure all our resources are cleaned up when the test is done.
	t.Cleanup(func() {
		mind.Stop()
		bus.Shutdown()
	})

	return mind, mockLLM, mockKG, bus
}

// -- Test Cases: Initialization and State Management --

// TestNewLLMMind_Initialization verifies the initial state and configuration.
func TestNewLLMMind_Initialization(t *testing.T) {
	mind, _, _, _ := setupLLMMind(t)

	// Peeking inside to verify the initial state.
	assert.Equal(t, StateInitializing, mind.currentState)
	assert.NotNil(t, mind.stateReadyChan)
}

// TestLLMMind_SetMission verifies the transition when a new mission is assigned.
func TestLLMMind_SetMission(t *testing.T) {
	mind, _, mockKG, _ := setupLLMMind(t)

	mission := Mission{ID: "mission-set-test", Objective: "Test Objective"}

	// When a mission is set, we expect the mind to first check if a node
	// for this mission already exists in the knowledge graph.
	mockKG.On("GetNode", mock.Anything, "mission-set-test").Return(schemas.Node{}, errors.New("not found")).Once()
	// Since it doesn't exist, it should then add a new mission node.
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(node schemas.Node) bool {
		return node.Type == schemas.NodeMission
	})).Return(nil).Once()

	// Let's do it.
	mind.SetMission(mission)

	// Now verify the state changed as expected.
	mind.mu.RLock()
	assert.Equal(t, StateObserving, mind.currentState)
	assert.Equal(t, "mission-set-test", mind.currentMission.ID)
	mind.mu.RUnlock()

	// A signal should have been sent to kick off the decision loop.
	select {
	case <-mind.stateReadyChan:
	// This is what we wanted.
	default:
		t.Fatal("SetMission did not signal the stateReadyChan as expected")
	}
}

// -- Test Cases: Prompt Generation and Parsing --

// TestParseActionResponse verifies the robust parsing of LLM responses, including markdown formatting.
func TestParseActionResponse(t *testing.T) {
	mind, _, _, _ := setupLLMMind(t)

	// The action we expect to get back from a valid response.
	expectedAction := Action{
		Type:      ActionNavigate,
		Value:     "http://example.com/login",
		Rationale: "Start at login page.",
	}
	validJSON, _ := json.Marshal(expectedAction)

	tests := []struct {
		name        string
		response    string
		expectError bool
		expectType  ActionType
	}{
		{"Valid Plain JSON", string(validJSON), false, ActionNavigate},
		{"Valid Markdown JSON Block", "```json\n" + string(validJSON) + "\n```", false, ActionNavigate},
		{"Valid Markdown Block (no lang)", "```\n" + string(validJSON) + "\n```", false, ActionNavigate},
		{"Extra text and Markdown", "Here is the plan:\n```json\n" + string(validJSON) + "\n```\nProceed.", false, ActionNavigate},
		{"Invalid JSON", `{"type": "NAVIGATE", "value": "http://missing_quote.com}`, true, ""},
		{"Missing Type Field", `{"value": "http://example.com"}`, true, ""},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Testing the unexported method directly.
			action, err := mind.parseActionResponse(tt.response)

			if tt.expectError {
				assert.Error(t, err)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expectType, action.Type)
			}
		})
	}
}

// -- Test Cases: OODA Loop Integration --

// TestOODALoop_HappyPath verifies the full cycle: SetMission -> Orient -> Decide -> Act -> Observe -> Orient...
func TestOODALoop_HappyPath(t *testing.T) {
	mind, mockLLM, mockKG, bus := setupLLMMind(t)
	// Use a context with timeout to prevent the test from hanging.
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel() // Safety net cancel

	missionID := "mission-ooda-happy"
	var action1ID string // Will capture the ID generated by the Mind

	missionNode := schemas.Node{ID: missionID, Type: schemas.NodeMission}

	// -- Setup: Mission Initialization (in SetMission) --
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{}, errors.New("not found")).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(node schemas.Node) bool {
		return node.Type == schemas.NodeMission
	})).Return(nil).Once()

	// -- Expectations for Cycle 1 (Mission Start -> Act) --
	mockKG.On("GetNode", mock.Anything, missionID).Return(missionNode, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Once()
	llmAction1 := Action{Type: ActionNavigate, Value: "http://start.com"}
	llmResponse1, _ := json.Marshal(llmAction1)
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return(string(llmResponse1), nil).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(node schemas.Node) bool {
		props := make(map[string]interface{})
		if node.Properties != nil {
			json.Unmarshal(node.Properties, &props)
		}
		if node.Type == schemas.NodeAction && props["status"] == string(schemas.StatusNew) {
			action1ID = node.ID
			return true
		}
		return false
	})).Return(nil).Once()
	mockKG.On("AddEdge", mock.Anything, mock.MatchedBy(func(edge schemas.Edge) bool {
		return edge.Type == schemas.RelationshipExecuted
	})).Return(nil).Once()

	// Let's get the mind's processing loops running in the background.
	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		if err := mind.Start(ctx); err != nil && !errors.Is(err, context.Canceled) && !errors.Is(err, context.DeadlineExceeded) {
			t.Logf("LLMMind Start returned unexpected error: %v", err)
		}
	}()

	actionChan, unsubscribeActions := bus.Subscribe(MessageTypeAction)
	defer unsubscribeActions()
	mind.SetMission(Mission{ID: missionID, Objective: "Test OODA Happy Path"})

	var postedAction1 Action
	select {
	case msg := <-actionChan:
		bus.Acknowledge(msg)
		var ok bool
		postedAction1, ok = msg.Payload.(Action)
		if !ok {
			t.Fatalf("Received non-Action payload on action channel: %T", msg.Payload)
		}
	case <-ctx.Done():
		t.Fatal("Timeout waiting for Cycle 1 Action on the bus")
	}
	require.NotEmpty(t, action1ID, "Action ID should have been captured during KG mock")
	assert.Equal(t, action1ID, postedAction1.ID)

	// -- Expectations for Cycle 2 (Observe -> Act/Conclude) --
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeObservation })).Return(nil).Once()
	mockKG.On("AddEdge", mock.Anything, mock.Anything).Return(nil).Once()
	action1Node := schemas.Node{ID: action1ID, Type: schemas.NodeAction, Properties: json.RawMessage(`{}`)}
	mockKG.On("GetNode", mock.Anything, action1ID).Return(action1Node, nil).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(node schemas.Node) bool {
		props := make(map[string]interface{})
		if node.Properties != nil {
			json.Unmarshal(node.Properties, &props)
		}
		return node.ID == action1ID && props["status"] == string(schemas.StatusAnalyzed)
	})).Return(nil).Once()
	mockKG.On("GetNode", mock.Anything, missionID).Return(missionNode, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{action1Node}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, action1ID).Return([]schemas.Node{}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, action1ID).Return([]schemas.Edge{}, nil).Once()
	llmAction2 := Action{Type: ActionConclude}
	llmResponse2, _ := json.Marshal(llmAction2)
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return(string(llmResponse2), nil).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeAction })).Return(nil).Once()
	mockKG.On("AddEdge", mock.Anything, mock.Anything).Return(nil).Once()

	observation := Observation{ID: "obs-1", SourceActionID: action1ID, Data: "success data", Result: ExecutionResult{Status: "success"}}
	err := bus.Post(ctx, CognitiveMessage{Type: MessageTypeObservation, Payload: observation})
	require.NoError(t, err)

	select {
	case msg := <-actionChan:
		bus.Acknowledge(msg)
		postedAction2, ok := msg.Payload.(Action)
		if !ok {
			t.Fatalf("Received non-Action payload on action channel in cycle 2: %T", msg.Payload)
		}
		assert.Equal(t, ActionConclude, postedAction2.Type)
	case <-ctx.Done():
		t.Fatal("Timeout waiting for Cycle 2 Action (Conclude) on the bus")
	}

	assert.Eventually(t, func() bool {
		mind.mu.RLock()
		defer mind.mu.RUnlock()
		return mind.currentState == StateCompleted
	}, 2*time.Second, 50*time.Millisecond)

	mockKG.AssertExpectations(t)
	mockLLM.AssertExpectations(t)

	cancel()
	wg.Wait()
}

// -- Test Cases: Robustness and Error Handling --

// Verifies the Mind transitions to StateFailed if observation processing fails.
func TestOODALoop_ObservationKGFailure(t *testing.T) {
	mind, mockLLM, mockKG, bus := setupLLMMind(t)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	missionID := "mission-fail-obs"

	// -- Mocks for the initial, unrelated decision cycle triggered by SetMission --
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{}, errors.New("not found")).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeMission })).Return(nil).Once()
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{ID: missionID}, nil).Maybe()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{}, nil).Maybe()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Maybe()
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return(`{"type": "NAVIGATE", "value": "http://init.com", "rationale": "initial action"}`, nil).Maybe()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeAction })).Return(nil).Maybe()
	mockKG.On("AddEdge", mock.Anything, mock.Anything).Return(nil).Maybe()

	// -- Mocks for the actual test scenario --
	expectedError := errors.New("KG critical failure")
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeObservation })).Return(expectedError).Once()

	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		mind.Start(ctx)
	}()

	mind.SetMission(Mission{ID: missionID})
	time.Sleep(50 * time.Millisecond)
	observation := Observation{ID: "obs-fail", Data: "some data"}
	err := bus.Post(ctx, CognitiveMessage{Type: MessageTypeObservation, Payload: observation})
	require.NoError(t, err)

	assert.Eventually(t, func() bool {
		mind.mu.RLock()
		defer mind.mu.RUnlock()
		return mind.currentState == StateFailed
	}, 2*time.Second, 50*time.Millisecond)

	cancel()
	wg.Wait()
}

// Verifies the Mind handles LLM API failures gracefully.
func TestOODALoop_DecisionLLMFailure(t *testing.T) {
	mind, mockLLM, mockKG, _ := setupLLMMind(t)
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	missionID := "mission-llm-fail"
	missionNode := schemas.Node{ID: missionID, Type: schemas.NodeMission}

	cycleCompleteWg := sync.WaitGroup{}
	cycleCompleteWg.Add(1)

	// -- Mock Setup in strict execution order --
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{}, errors.New("not found")).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeMission })).Return(nil).Once()
	mockKG.On("GetNode", mock.Anything, missionID).Return(missionNode, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Once()
	expectedError := errors.New("LLM API timeout")
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return("", expectedError).Once().Run(func(args mock.Arguments) {
		cycleCompleteWg.Done()
	})

	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		mind.Start(ctx)
	}()
	mind.SetMission(Mission{ID: missionID})

	if !waitTimeout(&cycleCompleteWg, 5*time.Second) {
		t.Fatal("Timeout waiting for the OODA loop (LLM Generate call) to execute.")
	}

	assert.Eventually(t, func() bool {
		mind.mu.RLock()
		currentState := mind.currentState
		mind.mu.RUnlock()
		return currentState == StateObserving
	}, 1*time.Second, 50*time.Millisecond, "Mind should return to OBSERVING after LLM failure")

	mockLLM.AssertExpectations(t)
	mockKG.AssertExpectations(t)

	cancel()
	wg.Wait()
}

// Verifies the Mind fails if it cannot record its decided action.
func TestOODALoop_ActionKGFailure(t *testing.T) {
	mind, mockLLM, mockKG, _ := setupLLMMind(t)
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	missionID := "mission-action-kg-fail"
	missionNode := schemas.Node{ID: missionID, Type: schemas.NodeMission}

	// -- Mock Setup in strict execution order --
	mockKG.On("GetNode", mock.Anything, missionID).Return(schemas.Node{}, errors.New("not found")).Once()
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeMission })).Return(nil).Once()
	mockKG.On("GetNode", mock.Anything, missionID).Return(missionNode, nil).Once()
	mockKG.On("GetNeighbors", mock.Anything, missionID).Return([]schemas.Node{}, nil).Once()
	mockKG.On("GetEdges", mock.Anything, missionID).Return([]schemas.Edge{}, nil).Once()
	llmResponse, _ := json.Marshal(Action{Type: ActionClick})
	mockLLM.On("Generate", mock.Anything, mock.Anything).Return(string(llmResponse), nil).Once()
	expectedError := errors.New("KG write failure")
	mockKG.On("AddNode", mock.Anything, mock.MatchedBy(func(n schemas.Node) bool { return n.Type == schemas.NodeAction })).Return(expectedError).Once()

	var wg sync.WaitGroup
	wg.Add(1)
	go func() {
		defer wg.Done()
		mind.Start(ctx)
	}()
	mind.SetMission(Mission{ID: missionID})

	assert.Eventually(t, func() bool {
		mind.mu.RLock()
		defer mind.mu.RUnlock()
		return mind.currentState == StateFailed
	}, 2*time.Second, 50*time.Millisecond)

	cancel()
	wg.Wait()
}