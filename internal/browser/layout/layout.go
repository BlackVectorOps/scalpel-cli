package layout

import (
    "fmt"
    "math"
    "sort"
    "strings"

    "github.com/antchfx/htmlquery"
    "golang.org/x/net/html"

    "github.com/xkilldash9x/scalpel-cli/api/schemas"
    "github.com/xkilldash9x/scalpel-cli/internal/browser/parser"
    "github.com/xkilldash9x/scalpel-cli/internal/browser/style"
)

// -- Constants and Configuration --

const (
    BaseFontSize      = 16.0 // Default root font size.
    DefaultLineHeight = 1.2  // Default multiplier for 'line-height: normal'.
)

// -- Core Structures: Box Model and Dimensions --

// Dimensions defines the geometry of a layout box.
type Dimensions struct {
    // Content area (x, y) relative to the viewport (before transforms).
    Content Rect

    Padding Edges
    Border  Edges
    Margin  Edges
    // Stores the cumulative transformation matrix from the root.
    Transform TransformMatrix
}

// MarginBox returns the rectangle enclosing the margin area.
func (d Dimensions) MarginBox() Rect {
    return d.BorderBox().ExpandedBy(d.Margin)
}

// BorderBox returns the rectangle enclosing the border area.
func (d Dimensions) BorderBox() Rect {
    return d.PaddingBox().ExpandedBy(d.Border)
}

// PaddingBox returns the rectangle enclosing the padding area.
func (d Dimensions) PaddingBox() Rect {
    return d.Content.ExpandedBy(d.Padding)
}

type Rect struct {
    X, Y, Width, Height float64
}

// ExpandedBy returns a new rectangle expanded by the edge sizes.
func (r Rect) ExpandedBy(e Edges) Rect {
    return Rect{
        X:      r.X - e.Left,
        Y:      r.Y - e.Top,
        Width:  r.Width + e.Left + e.Right,
        Height: r.Height + e.Top + e.Bottom,
    }
}

type Edges struct {
    Top, Right, Bottom, Left float64
}

// -- CSS Transforms (2D) --

// TransformMatrix represents a 2D affine transformation matrix (3x3).
// [ a c e ]
// [ b d f ]
// [ 0 0 1 ]
type TransformMatrix struct {
    A, B, C, D, E, F float64
}

// IdentityMatrix returns the identity matrix (no transformation).
func IdentityMatrix() TransformMatrix {
    return TransformMatrix{A: 1, D: 1}
}

// Multiply combines two matrices (m1 * m2). Order matters.
func (m1 TransformMatrix) Multiply(m2 TransformMatrix) TransformMatrix {
    return TransformMatrix{
        A: m1.A*m2.A + m1.C*m2.B,
        B: m1.B*m2.A + m1.D*m2.B,
        C: m1.A*m2.C + m1.C*m2.D,
        D: m1.B*m2.C + m1.D*m2.D,
        E: m1.A*m2.E + m1.C*m2.F + m1.E,
        F: m1.B*m2.E + m1.D*m2.F + m1.F,
    }
}

// Apply transforms a point (x, y).
func (m TransformMatrix) Apply(x, y float64) (float64, float64) {
    newX := m.A*x + m.C*y + m.E
    newY := m.B*x + m.D*y + m.F
    return newX, newY
}

// -- Layout Tree (Box Tree) --

// BoxType defines the type of box generated by a node.
type BoxType int

const (
    BlockBox BoxType = iota
    InlineBox
    InlineBlockBox
    AnonymousBlockBox
    FlexContainer
    GridContainer
    TableBox
    TableRowGroup
    TableRow
    TableCell
)

// LayoutBox is a node in the Layout Tree.
type LayoutBox struct {
    Dimensions      Dimensions
    BoxType         BoxType
    StyledNode      *style.StyledNode
    Children        []*LayoutBox
    ContainingBlock *LayoutBox
    Floats          *FloatList
    BaselineOffset  float64 // Y offset from content-box top to the baseline.
    crossAxisOffset float64 // Temporary storage for alignment shifts.
}

func NewLayoutBox(boxType BoxType, styledNode *style.StyledNode) *LayoutBox {
    return &LayoutBox{
        BoxType:    boxType,
        StyledNode: styledNode,
        Dimensions: Dimensions{Transform: IdentityMatrix()},
    }
}

// IsBlockLevel checks if the box participates in a BFC.
func (b *LayoutBox) IsBlockLevel() bool {
    switch b.BoxType {
    case BlockBox, FlexContainer, GridContainer, TableBox, AnonymousBlockBox:
        return true
    default:
        return false
    }
}

// EstablishesNewFormattingContext checks if this box creates a new Block Formatting Context (BFC).
func (b *LayoutBox) EstablishesNewFormattingContext() bool {
    if b.StyledNode == nil {
        return b.BoxType == AnonymousBlockBox
    }

    if b.ContainingBlock == nil {
        return true
    } // Root (ICB)
    if b.StyledNode.Float() != style.FloatNone {
        return true
    }
    pos := b.StyledNode.Position()
    if pos == style.PositionAbsolute || pos == style.PositionFixed {
        return true
    }

    switch b.BoxType {
    case InlineBlockBox, FlexContainer, GridContainer, TableBox:
        return true
    }

    overflow := b.StyledNode.Lookup("overflow", "visible")
    if overflow != "visible" && overflow != "clip" {
        return true
    }

    return false
}

// GetInlineContainer manages the creation of AnonymousBlockBoxes for inline content.
func (b *LayoutBox) GetInlineContainer() *LayoutBox {
    switch b.BoxType {
    case InlineBox, InlineBlockBox, AnonymousBlockBox:
        return b
    case BlockBox:
        // Reuse or create anonymous block box.
        if len(b.Children) > 0 {
            if lastChild := b.Children[len(b.Children)-1]; lastChild.BoxType == AnonymousBlockBox {
                return lastChild
            }
        }
        anonBox := NewLayoutBox(AnonymousBlockBox, nil)
        // Note: The anonBox is added to b.Children during BuildLayoutTree traversal.
        return anonBox
    case FlexContainer, GridContainer, TableBox:
        // These containers manage their children directly (they become flex/grid items).
        return b
    }
    return b
}

// -- Engine Core --

type Engine struct {
    userAgentSheets []parser.StyleSheet
    authorSheets    []parser.StyleSheet
    viewportWidth   float64
    viewportHeight  float64
}

func NewEngine() *Engine {
    e := &Engine{}
    return e
}

// AddStyleSheet adds a stylesheet provided by the webpage author.
func (e *Engine) AddStyleSheet(sheet parser.StyleSheet) {
    e.authorSheets = append(e.authorSheets, sheet)
}

// Render orchestrates the entire rendering process.
func (e *Engine) Render(root *html.Node, viewportWidth, viewportHeight float64) *LayoutBox {
    e.viewportWidth = viewportWidth
    e.viewportHeight = viewportHeight

    // 1. Build Style Tree.
    styleTree := e.BuildStyleTree(root, nil)

    // 2. Build Layout Tree.
    layoutTree := e.BuildLayoutTree(styleTree)

    if layoutTree == nil {
        return nil
    }

    // 3. Perform Layout.
    // Initialize the ICB (Initial Containing Block).
    layoutTree.Dimensions.Content = Rect{X: 0, Y: 0, Width: viewportWidth, Height: viewportHeight}
    layoutTree.ContainingBlock = nil
    layoutTree.Floats = NewFloatList()

    // Start the recursive layout process.
    layoutTree.Layout(e)

    // Adjust the ICB height based on the final content extent (if auto).
    if layoutTree.StyledNode != nil && layoutTree.StyledNode.Lookup("height", "auto") == "auto" {
        layoutTree.calculateBlockHeight()
    }

    // 4. Apply Transforms (Post-Layout).
    layoutTree.applyTransforms(IdentityMatrix())

    return layoutTree
}

// -- Style Tree Construction (The Cascade and Inheritance) --

// BuildStyleTree constructs the StyledNode tree.
func (e *Engine) BuildStyleTree(node *html.Node, parent *style.StyledNode) *style.StyledNode {
    computedStyles := make(map[parser.Property]parser.Value)

    // Calculate styles based on the cascade.
    if node.Type == html.ElementNode {
        computedStyles = e.CalculateStyles(node)
    }

    styledNode := &style.StyledNode{
        Node:           node,
        ComputedStyles: computedStyles,
    }

    // Handle inheritance.
    if parent != nil {
        e.inheritStyles(styledNode, parent)
    } else {
        e.applyRootDefaults(styledNode)
    }

    // Resolve relative values.
    e.resolveRelativeValues(styledNode, parent)

    // Recursively style children.
    for c := node.FirstChild; c != nil; c = c.NextSibling {
        if c.Type == html.CommentNode {
            continue
        }
        // Skip <head>.
        if node.Type == html.ElementNode && strings.ToLower(node.Data) == "html" && c.Type == html.ElementNode && strings.ToLower(c.Data) == "head" {
            continue
        }

        childStyled := e.BuildStyleTree(c, styledNode)
        styledNode.Children = append(styledNode.Children, childStyled)
    }

    return styledNode
}

func (e *Engine) applyRootDefaults(sn *style.StyledNode) {
    if _, exists := sn.ComputedStyles["font-size"]; !exists {
        sn.ComputedStyles["font-size"] = parser.Value(fmt.Sprintf("%fpx", BaseFontSize))
    }
}

// inheritStyles applies inheritance rules.
func (e *Engine) inheritStyles(child, parent *style.StyledNode) {
    inheritableProperties := map[parser.Property]bool{
        "color": true, "font-family": true, "font-size": true, "font-weight": true,
        "line-height": true, "text-align": true, "visibility": true, "cursor": true,
    }

    // Handle explicit 'inherit'.
    for prop, val := range child.ComputedStyles {
        if val == "inherit" {
            if parentVal, parentHas := parent.ComputedStyles[prop]; parentHas {
                child.ComputedStyles[prop] = parentVal
            }
        }
    }

    // Handle standard inheritance.
    for prop := range inheritableProperties {
        if _, exists := child.ComputedStyles[prop]; !exists {
            if val, parentHas := parent.ComputedStyles[prop]; parentHas {
                child.ComputedStyles[prop] = val
            }
        }
    }
}

// resolveRelativeValues computes values that depend on other computed values (e.g., em units).
func (e *Engine) resolveRelativeValues(sn *style.StyledNode, parent *style.StyledNode) {
    // Resolve font-size first.
    parentFontSize := BaseFontSize
    if parent != nil {
        parentFontSize = parseAbsoluteLength(parent.Lookup("font-size", fmt.Sprintf("%fpx", BaseFontSize)))
    }

    if fontSizeStr, ok := sn.ComputedStyles["font-size"]; ok {
        resolvedFontSize := parseLengthWithUnits(string(fontSizeStr), parentFontSize, BaseFontSize, parentFontSize, e.viewportWidth, e.viewportHeight)
        sn.ComputedStyles["font-size"] = parser.Value(fmt.Sprintf("%fpx", resolvedFontSize))
    }

    currentFontSize := parseAbsoluteLength(sn.Lookup("font-size", fmt.Sprintf("%fpx", BaseFontSize)))

    // Resolve line-height.
    if lineHeightStr, ok := sn.ComputedStyles["line-height"]; ok {
        resolvedLineHeight := e.resolveLineHeight(string(lineHeightStr), currentFontSize)
        sn.ComputedStyles["line-height"] = parser.Value(fmt.Sprintf("%fpx", resolvedLineHeight))
    }
}

// resolveLineHeight handles unitless multipliers.
func (e *Engine) resolveLineHeight(value string, fontSize float64) float64 {
    value = strings.TrimSpace(value)
    if value == "normal" {
        return fontSize * DefaultLineHeight
    }

    // Check for unitless number (multiplier).
    if val, err := parseFloat(value); err == nil && !strings.ContainsAny(value, "px%emrem") {
        return fontSize * val
    }

    // Treat as a length.
    return parseLengthWithUnits(value, fontSize, BaseFontSize, 0, e.viewportWidth, e.viewportHeight)
}

// StyleOrigin and DeclarationWithContext definitions.
type StyleOrigin int

const (
    OriginUserAgent StyleOrigin = iota
    OriginAuthor
    OriginInline
)

type DeclarationWithContext struct {
    Declaration parser.Declaration
    Specificity struct{ A, B, C int }
    Origin      StyleOrigin
    Order       int
}

// CalculateStyles determines the computed styles using the cascade algorithm.
func (e *Engine) CalculateStyles(node *html.Node) map[parser.Property]parser.Value {
    var declarations []DeclarationWithContext
    order := 0

    // internal/browser/layout/layout.go -> inside CalculateStyles()

// Helper function to process stylesheets.
processSheets := func(sheets []parser.StyleSheet, origin StyleOrigin) {
    for _, sheet := range sheets {
        for _, rule := range sheet.Rules {
            // A rule matches if ANY selector group in the list matches.
            for _, selectorGroup := range rule.SelectorGroups {
                // The 'matches' function now returns the specific ComplexSelector that matched.
                if matchingComplexSelector, ok := e.matches(node, selectorGroup); ok {
                    // Use the specificity of the matching complex selector.
                    a, b, c := matchingComplexSelector.CalculateSpecificity()
                    for _, decl := range rule.Declarations {
                        declarations = append(declarations, DeclarationWithContext{
                            Declaration: decl,
                            Specificity: struct{ A, B, C int }{a, b, c},
                            Origin:      origin,
                            Order:       order,
                        })
                        order++
                    }
                    // Optimization: Once a group matches, we don't need to check others in the same rule.
                    break
                }
            }
        }
    }
}

    // 1. Process User Agent and Author sheets.
    processSheets(e.userAgentSheets, OriginUserAgent)
    processSheets(e.authorSheets, OriginAuthor)

    // 2. Process Inline Styles.
    for _, attr := range node.Attr {
        if attr.Key == "style" {
            inlineDecls := parseInlineStyles(attr.Val)
            for _, decl := range inlineDecls {
                declarations = append(declarations, DeclarationWithContext{
                    Declaration: decl,
                    // Inline styles specificity (1,0,0,0).
                    Specificity: struct{ A, B, C int }{1000, 0, 0},
                    Origin:      OriginInline,
                    Order:       order,
                })
                order++
            }
        }
    }

    // 3. Sort declarations (The Cascade).
    sort.Slice(declarations, func(i, j int) bool {
        d1, d2 := declarations[i], declarations[j]

        // Origin and Importance.
        p1, p2 := calculateCascadePriority(d1), calculateCascadePriority(d2)
        if p1 != p2 {
            return p1 < p2
        }

        // Specificity.
        s1, s2 := d1.Specificity, d2.Specificity
        if s1.A != s2.A {
            return s1.A < s2.A
        }
        if s1.B != s2.B {
            return s1.B < s2.B
        }
        if s1.C != s2.C {
            return s1.C < s2.C
        }

        // Order.
        return d1.Order < d2.Order
    })

    // 4. Apply rules.
    styles := make(map[parser.Property]parser.Value)
    for _, declCtx := range declarations {
        styles[declCtx.Declaration.Property] = declCtx.Declaration.Value
    }

    // 5. Expand Shorthands (e.g., Flex).
    expandFlexShorthand(styles)

    return styles
}

// expandFlexShorthand handles the 'flex' property expansion into grow, shrink, and basis.
func expandFlexShorthand(styles map[parser.Property]parser.Value) {
    flexVal, ok := styles["flex"]
    if !ok {
        return
    }

    // Default values: flex: 0 1 auto
    grow, shrink, basis := "0", "1", "auto"

    // Simplified parsing of the 'flex' value.
    parts := strings.Fields(string(flexVal))

    if len(parts) == 1 {
        switch parts[0] {
        case "none":
            grow, shrink, basis = "0", "0", "auto"
        case "auto":
            grow, shrink, basis = "1", "1", "auto"
        default:
            // Check if it's a unitless number (flex-grow) or a length (flex-basis).
            // Heuristic check for units.
            isLength := strings.ContainsAny(parts[0], "px%emrem") || (parts[0] == "0" && len(parts[0]) == 1)
            if _, err := parseFloat(parts[0]); err == nil && !isLength {
                grow = parts[0]
            } else {
                basis = parts[0]
                grow = "1" // When basis is specified alone (e.g., flex: 100px), grow defaults to 1.
                shrink = "1"
            }
        }
    } else if len(parts) == 2 {
        // <flex-grow> <flex-shrink> OR <flex-grow> <flex-basis>.
        grow = parts[0]
        // Check if the second part is a unitless number or a length.
        isLength := strings.ContainsAny(parts[1], "px%emrem") || (parts[1] == "0" && len(parts[1]) == 1)
        if _, err := parseFloat(parts[1]); err == nil && !isLength {
            shrink = parts[1]
        } else {
            basis = parts[1]
        }
    } else if len(parts) >= 3 {
        // <flex-grow> <flex-shrink> <flex-basis>.
        grow = parts[0]
        shrink = parts[1]
        basis = parts[2]
    }

    styles["flex-grow"] = parser.Value(grow)
    styles["flex-shrink"] = parser.Value(shrink)
    styles["flex-basis"] = parser.Value(basis)
}

// calculateCascadePriority assigns weights based on origin and !important status.
func calculateCascadePriority(d DeclarationWithContext) int {
    // Order (lowest number wins): 1. UA normal, 2. Author normal, 3. Inline normal, 4. !important Author/Inline, 5. UA !important.
    isImportant := d.Declaration.Important
    switch d.Origin {
    case OriginUserAgent:
        if isImportant {
            return 5
        }
        return 1
    case OriginAuthor:
        if isImportant {
            return 4
        }
        return 2
    case OriginInline:
        if isImportant {
            return 4
        }
        return 3
    }
    return 0
}

// parseInlineStyles parses the content of a 'style' attribute.
func parseInlineStyles(styleAttr string) []parser.Declaration {
    var decls []parser.Declaration
    parts := strings.Split(styleAttr, ";")
    for _, part := range parts {
        part = strings.TrimSpace(part)
        if part == "" {
            continue
        }
        kv := strings.SplitN(part, ":", 2)
        if len(kv) == 2 {
            prop, val := strings.TrimSpace(kv[0]), strings.TrimSpace(kv[1])
            important := false
            if strings.HasSuffix(strings.ToLower(val), "!important") {
                important = true
                val = strings.TrimSpace(val[:len(val)-len("!important")])
            }
            decls = append(decls, parser.Declaration{
                Property: parser.Property(prop), Value: parser.Value(val), Important: important,
            })
        }
    }
    return decls
}

// -- Advanced Selector Matching (Combinators) --

// matches checks if a DOM node matches any of the ComplexSelectors in a SelectorGroup.
// It returns the matching ComplexSelector and true, or nil and false if no match.
func (e *Engine) matches(node *html.Node, group parser.SelectorGroup) (*parser.ComplexSelector, bool) {
    if node.Type != html.ElementNode {
        return nil, false
    }

    for _, complexSelector := range group {
        // Start matching from the rightmost simple selector within the complex selector.
        currentIndex := len(complexSelector.Selectors) - 1
        if currentIndex < 0 {
            continue
        }
        if e.recursiveMatch(node, complexSelector, currentIndex) {
            // Found a match
            return &complexSelector, true
        }
    }

    return nil, false // No match found
}


// recursiveMatch handles the logic of traversing the DOM based on combinators.
func (e *Engine) recursiveMatch(node *html.Node, complexSelector parser.ComplexSelector, index int) bool {
    if node == nil || index < 0 {
        return false
    }

    // Ensure we only check element nodes during traversal.
    if node.Type != html.ElementNode {
        return false
    }

    currentSelectorWithCombinator := complexSelector.Selectors[index]

    // 1. Check if the current node matches the simple selector part.
    if !e.matchesSimple(node, currentSelectorWithCombinator.SimpleSelector) {
        return false
    }

    // 2. If it matches, check if we are done.
    if index == 0 {
        return true
    }

    // 3. If it matches and there are more selectors, apply the combinator logic.
    nextIndex := index - 1
    combinator := currentSelectorWithCombinator.Combinator

    switch combinator {
    case parser.CombinatorDescendant:
        // Check ancestors.
        for parent := node.Parent; parent != nil; parent = parent.Parent {
            if e.recursiveMatch(parent, complexSelector, nextIndex) {
                return true
            }
        }
        return false

    case parser.CombinatorChild:
        // Check the immediate parent.
        return e.recursiveMatch(node.Parent, complexSelector, nextIndex)

    case parser.CombinatorAdjacentSibling:
        // Check the immediately preceding element sibling.
        prevSibling := getPreviousElementSibling(node)
        return e.recursiveMatch(prevSibling, complexSelector, nextIndex)

    case parser.CombinatorGeneralSibling:
        // Check all preceding element siblings.
        for sibling := getPreviousElementSibling(node); sibling != nil; sibling = getPreviousElementSibling(sibling) {
            if e.recursiveMatch(sibling, complexSelector, nextIndex) {
                return true
            }
        }
        return false
    case parser.CombinatorNone:
        // Should not happen if index > 0.
        return true
    }

    return false
}

// getPreviousElementSibling finds the previous sibling that is an Element node.
func getPreviousElementSibling(node *html.Node) *html.Node {
    sibling := node.PrevSibling
    for sibling != nil {
        if sibling.Type == html.ElementNode {
            return sibling
        }
        sibling = sibling.PrevSibling
    }
    return nil
}

// matchesSimple checks if a DOM node matches a simple CSS selector (no combinators).
func (e *Engine) matchesSimple(node *html.Node, selector parser.SimpleSelector) bool {
    // Check Tag Name
    if selector.TagName != "" && selector.TagName != "*" && strings.ToLower(node.Data) != selector.TagName {
        return false
    }

    // Check ID
    if selector.ID != "" {
        idFound := false
        for _, attr := range node.Attr {
            if attr.Key == "id" && attr.Val == selector.ID {
                idFound = true
                break
            }
        }
        if !idFound {
            return false
        }
    }

    // Check Classes
    if len(selector.Classes) > 0 {
        var nodeClasses []string
        for _, attr := range node.Attr {
            if attr.Key == "class" {
                nodeClasses = strings.Fields(attr.Val)
                break
            }
        }

        for _, requiredClass := range selector.Classes {
            found := false
            for _, nodeClass := range nodeClasses {
                if nodeClass == requiredClass {
                    found = true
                    break
                }
            }
            if !found {
                return false
            }
        }
    }

    return true
}

// -- Layout Tree Construction --

// BuildLayoutTree constructs the LayoutBox tree from the Style Tree (Box Construction).
func (e *Engine) BuildLayoutTree(styledNode *style.StyledNode) *LayoutBox {
    display := styledNode.Display()

    if display == style.DisplayNone {
        return nil
    }

    // Blockification: Adjust display type based on positioning and floats.
    position := styledNode.Position()
    isPositioned := position == style.PositionAbsolute || position == style.PositionFixed
    isFloated := styledNode.Float() != style.FloatNone

    if isPositioned || isFloated {
        // Elements become block-level if positioned or floated.
        switch display {
        case style.DisplayInline, style.DisplayInlineBlock, style.DisplayTable:
            display = style.DisplayBlock
        }
    }

    var root *LayoutBox
    switch display {
    case style.DisplayBlock:
        root = NewLayoutBox(BlockBox, styledNode)
    case style.DisplayFlex:
        root = NewLayoutBox(FlexContainer, styledNode)
    case style.DisplayGrid:
        root = NewLayoutBox(GridContainer, styledNode)
    case style.DisplayTable:
        root = NewLayoutBox(TableBox, styledNode)
    case style.DisplayTableRow:
        root = NewLayoutBox(TableRow, styledNode)
    case style.DisplayTableCell:
        root = NewLayoutBox(TableCell, styledNode)
    case style.DisplayInlineBlock:
        root = NewLayoutBox(InlineBlockBox, styledNode)
    case style.DisplayInline:
        // Optimization: Skip whitespace-only text nodes.
        if styledNode.Node.Type == html.TextNode && strings.TrimSpace(styledNode.Node.Data) == "" {
            return nil
        }
        root = NewLayoutBox(InlineBox, styledNode)
    }

    if root.BoxType == TableBox {
        e.fixupTableStructure(root)
        return root
    }

    // Recursively build for children.
    for _, childStyled := range styledNode.Children {
        childBox := e.BuildLayoutTree(childStyled)
        if childBox == nil {
            continue
        }

        // Determine how to organize children based on the parent's formatting context.
        switch root.BoxType {
        case FlexContainer, GridContainer:
            // Flex/Grid items are appended directly.
            // Blockification of flex/grid items (e.g., inline child becomes block-level item).
            if !childBox.IsBlockLevel() && childBox.BoxType != InlineBlockBox {
                // Text nodes (InlineBox) are wrapped in an anonymous block-level flex item.
                // Simplified: Change the BoxType to BlockBox for layout purposes.
                childBox.BoxType = BlockBox
            }
            root.Children = append(root.Children, childBox)
        default:
            // Block/Inline flow.
            if childBox.IsBlockLevel() {
                root.Children = append(root.Children, childBox)
            } else {
                // Inline children must be wrapped in an anonymous container if the parent is block-level.
                container := root.GetInlineContainer()
                // Ensure the container is added to the root's children list if it's newly created.
                if container != root && (len(root.Children) == 0 || root.Children[len(root.Children)-1] != container) {
                    root.Children = append(root.Children, container)
                }
                container.Children = append(container.Children, childBox)
            }
        }
    }
    return root
}

func (e *Engine) fixupTableStructure(tableBox *LayoutBox) {
    if tableBox.StyledNode == nil {
        return
    }

    var currentRow *LayoutBox
    var currentSection *LayoutBox // Represents tbody, thead, tfoot

    for _, childStyled := range tableBox.StyledNode.Children {
        childDisplay := childStyled.Display()
        if childDisplay == style.DisplayNone {
            continue
        }

        childBox := e.BuildLayoutTree(childStyled) // Build the child box first
        if childBox == nil {
            continue
        }

        // Simplified logic: 'td' -> 'tr' -> 'tbody'
        isCell := childBox.BoxType == TableCell
        isRow := childBox.BoxType == TableRow

        if isCell {
            if currentSection == nil {
                // Cell needs a tbody.
                currentSection = NewLayoutBox(TableRowGroup, nil) // Anonymous tbody
                tableBox.Children = append(tableBox.Children, currentSection)
            }
            if currentRow == nil {
                // Cell needs a tr.
                currentRow = NewLayoutBox(TableRow, nil) // Anonymous tr
                currentSection.Children = append(currentSection.Children, currentRow)
            }
            currentRow.Children = append(currentRow.Children, childBox)
        } else if isRow {
            if currentSection == nil {
                currentSection = NewLayoutBox(TableRowGroup, nil) // Anonymous tbody
                tableBox.Children = append(tableBox.Children, currentSection)
            }
            currentSection.Children = append(currentSection.Children, childBox)
            currentRow = childBox // This row is explicit, so reset the anonymous one.
        } else {
            // For simplicity, treat other elements like 'tbody' as section wrappers.
            tableBox.Children = append(tableBox.Children, childBox)
            currentSection = childBox
            currentRow = nil
        }
    }
}

// -- Layout Algorithm (Flow, Positioning, Floats, Flexbox, Grid) --

// LayoutContext holds state during layout for BFCs (margin collapsing).
type LayoutContext struct {
    CurrentY          float64
    MaxNegativeMargin float64
    MaxPositiveMargin float64
    IsEmpty           bool
}

func NewLayoutContext(startY float64) *LayoutContext {
    return &LayoutContext{
        CurrentY: startY,
        IsEmpty:  true,
    }
}

func (lc *LayoutContext) AddToMarginTotals(margin float64) {
    if margin > 0 {
        lc.MaxPositiveMargin = math.Max(lc.MaxPositiveMargin, margin)
    } else {
        if margin < lc.MaxNegativeMargin {
            lc.MaxNegativeMargin = margin
        }
    }
}

func (lc *LayoutContext) CalculateCollapsedMargin() float64 {
    return lc.MaxPositiveMargin + lc.MaxNegativeMargin
}

func (lc *LayoutContext) ResetMargins() {
    lc.MaxNegativeMargin = 0
    lc.MaxPositiveMargin = 0
}

// Layout calculates the dimensions and position recursively.
func (b *LayoutBox) Layout(e *Engine) {
    // Initialize formatting context and float list inheritance.
    if b.EstablishesNewFormattingContext() {
        if b.Floats == nil {
            b.Floats = NewFloatList()
        }
    } else if b.ContainingBlock != nil {
        b.Floats = b.ContainingBlock.Floats
    }

    // Check if this box is a flex item or grid item.
    isManagedItem := false
    if b.ContainingBlock != nil {
        if b.ContainingBlock.BoxType == FlexContainer || b.ContainingBlock.BoxType == GridContainer {
            isManagedItem = true
        }
    }

    // If it's not a managed item (i.e., it's in normal flow), dispatch to the standard layout function.
    if !isManagedItem {
        switch b.BoxType {
        case BlockBox:
            b.layoutBlock(e)
        case FlexContainer:
            b.layoutFlex(e)
        case GridContainer:
            b.layoutGrid(e)
        case TableBox:
            b.layoutTable(e)
        case InlineBlockBox:
            b.layoutBlock(e) // Internally laid out like a block.
        case InlineBox:
            b.layoutInline(e)
        case AnonymousBlockBox:
            b.layoutAnonymous(e)
        }
    } else {
        // If it is a managed item (e.g., Flex Item), its dimensions are set by the parent container.
        // We just need to layout its content internally.
        b.layoutContent(e)
    }

    // Handle out-of-flow (absolutely positioned) children.
    b.layoutPositionedChildren(e)

    // Apply 'position: relative' offsets.
    b.applyRelativePositioning()
}

// layoutContent performs the internal layout of a box after its dimensions are determined (used for Flex/Grid items).
func (b *LayoutBox) layoutContent(e *Engine) {
    // Note: Margins/Paddings/Borders should already be calculated by the parent container's algorithm (e.g., collectFlexItems).
    switch b.BoxType {
    case BlockBox, InlineBlockBox:
        b.layoutBlockFlow(e)
        // Recalculate height if it was auto, based on the now fixed width.
        b.calculateBlockHeight()
    case FlexContainer:
        // If the item itself is a flex container, run its layout algorithm.
        b.layoutFlex(e)
    case GridContainer:
        b.layoutGrid(e)
    case TableBox:
        b.layoutTable(e)
    case InlineBox:
        // Often text nodes or simple inline wrappers.
        b.layoutInlineFlow(e)
        b.calculateInlineDimensions()
    case AnonymousBlockBox:
        // Should be rare in Flex/Grid context due to blockification, but handled for safety.
        b.layoutInlineFlow(e)
        b.calculateBlockHeight()
    }
}

// layoutBlock implements the CSS block layout algorithm (for normal flow).
func (b *LayoutBox) layoutBlock(e *Engine) {
    // 1. Calculate width and horizontal edges.
    b.calculateBlockWidthAndEdges()

    // 2. Determine X position.
    if b.ContainingBlock != nil {
        cb := b.ContainingBlock.Dimensions
        b.Dimensions.Content.X = cb.Content.X + b.Dimensions.Margin.Left + b.Dimensions.Border.Left + b.Dimensions.Padding.Left
    }

    // 3. Layout children.
    b.layoutChildren(e)

    // 4. Calculate height (if auto).
    b.calculateBlockHeight()
}

// layoutAnonymous handles anonymous block boxes.
func (b *LayoutBox) layoutAnonymous(e *Engine) {
    if b.ContainingBlock == nil {
        return
    }
    cb := b.ContainingBlock.Dimensions
    b.Dimensions.Content.Width = cb.Content.Width

    // Layout inline children (IFC).
    b.layoutChildren(e)
    b.calculateBlockHeight()
}

// layoutInline handles inline elements.
func (b *LayoutBox) layoutInline(e *Engine) {
    // 1. Calculate edges.
    b.calculateInlineEdges()

    // 2. Layout children (IFC).
    b.layoutChildren(e)

    // 3. Calculate dimensions (shrink-to-fit).
    b.calculateInlineDimensions()
}

// layoutChildren dispatches layout based on the formatting context.
func (b *LayoutBox) layoutChildren(e *Engine) {
    // Flex, Grid, Table handle their children internally during their specific layout functions.
    switch b.BoxType {
    case FlexContainer, GridContainer, TableBox:
        return
    }

    // Determine formatting context type (BFC or IFC).
    isBFC := b.BoxType == BlockBox || (b.BoxType == InlineBlockBox && b.EstablishesNewFormattingContext())

    if isBFC {
        b.layoutBlockFlow(e)
    } else {
        b.layoutInlineFlow(e)
    }
}

// layoutBlockFlow handles the layout of block-level children within a BFC.
func (b *LayoutBox) layoutBlockFlow(e *Engine) {
    context := NewLayoutContext(b.Dimensions.Content.Y)

    for _, child := range b.Children {
        child.ContainingBlock = b

        // Handle out-of-flow.
        if child.StyledNode != nil {
            pos := child.StyledNode.Position()
            if pos == style.PositionAbsolute || pos == style.PositionFixed {
                continue
            }
        }

        // Handle Floats.
        if child.StyledNode != nil && child.StyledNode.Float() != style.FloatNone {
            b.layoutFloatedBox(child, e, context)
            context.IsEmpty = false
            context.ResetMargins()
            continue
        }

        // -- In-Flow Block Layout --

        // Pre-calculate child's width and edges.
        if child.IsBlockLevel() || child.BoxType == InlineBlockBox {
            if child.BoxType != AnonymousBlockBox {
                child.calculateBlockWidthAndEdges()
            }
        } else {
            // Inline children should be wrapped in AnonymousBlockBox.
            continue
        }

        // 1. Margin Collapsing (Top Margin).
        marginTop := child.Dimensions.Margin.Top

        if child.BoxType == AnonymousBlockBox || (child.StyledNode != nil && child.EstablishesNewFormattingContext()) {
            context.CurrentY += context.CalculateCollapsedMargin()
            context.ResetMargins()
        }

        context.AddToMarginTotals(marginTop)

        // 2. Handle Clearance.
        clearance := 0.0
        if child.StyledNode != nil && b.Floats != nil {
            clearType := child.StyledNode.Clear()
            if clearType != style.ClearNone {
                potentialY := context.CurrentY + context.CalculateCollapsedMargin()
                clearance = b.Floats.CalculateClearance(potentialY, clearType)
            }
        }

        if clearance > 0 {
            context.CurrentY += context.CalculateCollapsedMargin() + clearance
            context.ResetMargins()
        }

        // 3. Determine Y position.
        collapsedTopMargin := context.CalculateCollapsedMargin()
        child.Dimensions.Content.Y = context.CurrentY + collapsedTopMargin + child.Dimensions.Border.Top + child.Dimensions.Padding.Top

        // 4. Layout the child recursively.
        child.Layout(e)

        // 5. Update Layout Context.
        context.IsEmpty = false
        context.CurrentY += collapsedTopMargin + child.Dimensions.Border.Top + child.Dimensions.Padding.Top +
            child.Dimensions.Content.Height +
            child.Dimensions.Padding.Bottom + child.Dimensions.Border.Bottom

        // 6. Margin Collapsing (Bottom Margin).
        context.ResetMargins()
        context.AddToMarginTotals(child.Dimensions.Margin.Bottom)
    }

    context.CurrentY += context.CalculateCollapsedMargin()
}

// -- Inline Formatting Context (IFC) and Line Breaking --

// LineBox represents a horizontal line of content.
type LineBox struct {
    Rect
    Fragments []*LayoutBox
    BaselineY float64 // Y coordinate of the baseline relative to the viewport.
}

// layoutInlineFlow handles layout within an IFC.
func (b *LayoutBox) layoutInlineFlow(e *Engine) {
    containerWidth := b.Dimensions.Content.Width
    currentY := b.Dimensions.Content.Y

    var lineBoxes []*LineBox
    currentLine := &LineBox{Rect: Rect{Y: currentY}}
    lineBoxes = append(lineBoxes, currentLine)

    // Helper to update constraints based on floats.
    updateLineConstraints := func(line *LineBox, y float64) float64 {
        if b.Floats != nil {
            leftIndent, rightIndent := b.Floats.GetIndentationAtY(y, b.Dimensions.Content.X, containerWidth)
            line.X = b.Dimensions.Content.X + leftIndent
            return containerWidth - leftIndent - rightIndent
        }
        line.X = b.Dimensions.Content.X
        return containerWidth
    }

    availableWidth := updateLineConstraints(currentLine, currentY)
    currentX := currentLine.X

    for _, child := range b.Children {
        child.ContainingBlock = b
        child.Layout(e)

        childWidth := child.Dimensions.MarginBox().Width

        // Check for line break.
        if currentLine.Width+childWidth > availableWidth && currentLine.Width > 0 {
            // 1. Finalize current line height and baseline.
            b.calculateLineBoxHeightAndBaseline(currentLine)

            // 2. Create new line.
            currentY += currentLine.Height
            currentLine = &LineBox{Rect: Rect{Y: currentY}}
            lineBoxes = append(lineBoxes, currentLine)

            // 3. Update constraints.
            availableWidth = updateLineConstraints(currentLine, currentY)
            currentX = currentLine.X
        }

        // Place the child.
        child.Dimensions.Content.X = currentX + child.Dimensions.Margin.Left + child.Dimensions.Border.Left + child.Dimensions.Padding.Left
        // Y position is preliminary.
        child.Dimensions.Content.Y = currentY + child.Dimensions.Margin.Top + child.Dimensions.Border.Top + child.Dimensions.Padding.Top

        currentLine.Fragments = append(currentLine.Fragments, child)
        currentLine.Width += childWidth
        currentX += childWidth
    }

    // Finalize the last line.
    b.calculateLineBoxHeightAndBaseline(currentLine)

    // Perform vertical alignment.
    for _, line := range lineBoxes {
        b.verticallyAlignLineBox(line)
    }
}

// calculateLineBoxHeightAndBaseline determines the height and baseline based on font metrics.
func (b *LayoutBox) calculateLineBoxHeightAndBaseline(line *LineBox) {
    maxHeight := 0.0
    maxAscent := 0.0

    // Determine the effective height and ascent of each fragment.
    for _, frag := range line.Fragments {
        lineHeight := BaseFontSize * DefaultLineHeight
        ascent := getFontAscent(frag.StyledNode)

        if frag.StyledNode != nil {
            lineHeight = parseAbsoluteLength(frag.StyledNode.Lookup("line-height", fmt.Sprintf("%fpx", lineHeight)))
        }

        boxHeight := frag.Dimensions.BorderBox().Height
        effectiveHeight := math.Max(boxHeight, lineHeight)

        if effectiveHeight > maxHeight {
            maxHeight = effectiveHeight
        }
        if ascent > maxAscent {
            maxAscent = ascent
        }
    }

    // Fallback if the line is empty.
    if maxHeight == 0 {
        if b.StyledNode != nil {
            maxHeight = parseAbsoluteLength(b.StyledNode.Lookup("line-height", fmt.Sprintf("%fpx", BaseFontSize*DefaultLineHeight)))
            maxAscent = getFontAscent(b.StyledNode)
        } else {
            maxHeight = BaseFontSize * DefaultLineHeight
            maxAscent = BaseFontSize * 0.8 // Fallback heuristic if no styles available.
        }
    }

    line.Height = maxHeight
    // Baseline is the maximum ascent relative to the top of the line box.
    line.BaselineY = line.Y + maxAscent
}

// verticallyAlignLineBox adjusts Y coordinates based on 'vertical-align'.
func (b *LayoutBox) verticallyAlignLineBox(line *LineBox) {
    baselineY := line.BaselineY

    for _, frag := range line.Fragments {
        vAlign := "baseline"
        if frag.StyledNode != nil {
            vAlign = frag.StyledNode.Lookup("vertical-align", "baseline")
        }

        fragMarginBox := frag.Dimensions.MarginBox()
        offsetY := 0.0

        switch vAlign {
        case "top":
            offsetY = line.Y - fragMarginBox.Y
        case "bottom":
            offsetY = (line.Y + line.Height) - (fragMarginBox.Y + fragMarginBox.Height)
        case "middle":
            // Align middle of fragment with the baseline + 0.5ex (simplified approximation).
            fontSize := getFontSize(frag.StyledNode)
            // Heuristic: 1ex is approx 0.5 * font size.
            middleLine := baselineY - (0.5 * fontSize * 0.5)
            middleFrag := fragMarginBox.Y + fragMarginBox.Height/2
            offsetY = middleLine - middleFrag
        case "baseline":
            // Align baseline of fragment with baseline of line box.
            fragAscent := getFontAscent(frag.StyledNode)

            // Simplified handling for inline-block baseline (often the bottom margin edge if no internal flow).
            if frag.BoxType == InlineBlockBox && len(frag.Children) == 0 {
                targetMarginY := baselineY - fragMarginBox.Height
                offsetY = targetMarginY - fragMarginBox.Y
            } else {
                // Calculate target Y for the content box top.
                targetContentY := baselineY - fragAscent
                // Adjust based on the current content Y.
                offsetY = targetContentY - frag.Dimensions.Content.Y
            }
        }

        // Apply the offset.
        frag.Dimensions.Content.Y += offsetY
    }
}

// -- Flexbox Layout Implementation --

// Axis defines the main and cross axes for flex layout.
type Axis int

const (
    Horizontal Axis = iota
    Vertical
)

// FlexItemMetadata holds intermediate values during flex layout.
type FlexItemMetadata struct {
    Box                  *LayoutBox
    FlexBaseSize         float64
    HypotheticalMainSize float64
    TargetMainSize       float64
    Frozen               bool // Used during resolving flexible lengths.
    MinMainSize          float64
    MaxMainSize          float64
}

// FlexLine represents a line of flex items.
type FlexLine struct {
    Items     []*FlexItemMetadata
    CrossSize float64 // Height for rows, Width for columns.
    MainSize  float64 // Width for rows, Height for columns.
}

// layoutFlex implements the CSS Flexible Box Layout algorithm.
func (b *LayoutBox) layoutFlex(e *Engine) {
    // This function will be filled in later with detailed flexbox logic.
}

// -- Grid Layout (Simplified Implementation) --

type GridTrack struct {
    BaseSize     float64
    GrowthFactor float64 // Represents the 'fr' unit.
    MaxSize      float64
}
type GridItem struct {
    Box              *LayoutBox
    RowStart, RowEnd int
    ColStart, ColEnd int
    Row, Col         int
    RowSpan, ColSpan int
}

func (b *LayoutBox) layoutGrid(e *Engine) {
    // This function will be filled in later with detailed grid layout logic.
}

// -- Table Layout (Simplified Implementation) --

type TableColumn struct {
    MinWidth    float64
    MaxWidth    float64
    FinalWidth  float64
    IsSpecified bool // If a width was set via <col> or on a cell.
}

func (b *LayoutBox) layoutTable(e *Engine) {
    // This function will be filled in later with detailed table layout logic.
}

// -- Positioning (Absolute, Relative, Fixed) and Transforms --

func (b *LayoutBox) layoutPositionedChildren(e *Engine) {
    // This function will be filled in later.
}

func (b *LayoutBox) applyRelativePositioning() {
    // This function will be filled in later.
}

func (b *LayoutBox) applyTransforms(parentTransform TransformMatrix) {
    // This function will be filled in later.
}

// -- Floats --

// FloatList tracks active floats within a formatting context.
type FloatList struct {
    Floats []*LayoutBox
}

func NewFloatList() *FloatList {
    return &FloatList{}
}

func (fl *FloatList) CalculateClearance(currentY float64, clearType style.ClearType) float64 {
    return 0 // This function will be filled in later.
}

func (fl *FloatList) GetIndentationAtY(y, containerX, containerWidth float64) (leftIndent, rightIndent float64) {
    return 0, 0 // This function will be filled in later.
}

func (b *LayoutBox) layoutFloatedBox(child *LayoutBox, e *Engine, context *LayoutContext) {
    // This function will be filled in later.
}

// -- Box Model Calculations --

func (b *LayoutBox) calculateBlockWidthAndEdges() {
    // This function will be filled in later.
}

func (b *LayoutBox) calculatePaddingAndBorders(referenceWidth float64) {
    // This function will be filled in later.
}

func (b *LayoutBox) calculateMargins(referenceWidth float64) {
    // This function will be filled in later.
}

func (b *LayoutBox) calculateInlineEdges() {
    // This function will be filled in later.
}

func (b *LayoutBox) calculateBlockHeight() {
    // This function will be filled in later.
}

func (b *LayoutBox) calculateInlineDimensions() {
    // This function will be filled in later.
}

// -- Text Measurement and Font Metrics (Enhanced Heuristics) --

func getFontSize(sn *style.StyledNode) float64 {
    return 0 // This function will be filled in later.
}

func getFontAscent(sn *style.StyledNode) float64 {
    return 0 // This function will be filled in later.
}

func measureText(sn *style.StyledNode) (width, height float64) {
    return 0, 0 // This function will be filled in later.
}

// -- Helpers --

func (b *LayoutBox) getMainDimension(item *LayoutBox, axis Axis) float64 {
    if axis == Horizontal {
        return item.Dimensions.Content.Width
    }
    return item.Dimensions.Content.Height
}

func lookupStyle(styles map[parser.Property]parser.Value, property parser.Property, fallback string) string {
    if val, ok := styles[property]; ok {
        return string(val)
    }
    return fallback
}

func parseLengthWithUnits(value string, parentFontSize, rootFontSize, referenceDimension, viewportWidth, viewportHeight float64) float64 {
    value = strings.TrimSpace(value)
    if value == "" || value == "auto" || value == "normal" {
        return 0.0
    }

    if strings.HasSuffix(value, "%") {
        if percent, err := parseFloat(strings.TrimSuffix(value, "%")); err == nil {
            return referenceDimension * (percent / 100.0)
        }
    }

    if strings.HasSuffix(value, "px") {
        if px, err := parseFloat(strings.TrimSuffix(value, "px")); err == nil {
            return px
        }
    }

    if strings.HasSuffix(value, "em") {
        if val, err := parseFloat(strings.TrimSuffix(value, "em")); err == nil {
            return val * parentFontSize
        }
    }

    if strings.HasSuffix(value, "rem") {
        if val, err := parseFloat(strings.TrimSuffix(value, "rem")); err == nil {
            return val * rootFontSize
        }
    }

    if val, err := parseFloat(value); err == nil {
        return val
    }

    return 0.0
}

func parseAbsoluteLength(value string) float64 {
    return parseLengthWithUnits(value, 0, 0, 0, 0, 0)
}

func parseFloat(s string) (float64, error) {
    var result float64
    var sign float64 = 1
    var decimalPoint bool
    var decimalPlace float64 = 0.1

    if len(s) == 0 {
        return 0, fmt.Errorf("empty string")
    }

    i := 0
    if s[0] == '-' {
        sign = -1
        i++
    } else if s[0] == '+' {
        i++
    }

    parsedSomething := false
    for ; i < len(s); i++ {
        ch := s[i]
        if ch >= '0' && ch <= '9' {
            parsedSomething = true
            digit := float64(ch - '0')
            if decimalPoint {
                result += digit * decimalPlace
                decimalPlace *= 0.1
            } else {
                result = result*10 + digit
            }
        } else if ch == '.' && !decimalPoint {
            parsedSomething = true
            decimalPoint = true
        } else {
            break
        }
    }

    if !parsedSomething {
        return 0, fmt.Errorf("invalid float format: %s", s)
    }

    if result == 0 && sign == -1 {
        return 0, nil
    }

    return result * sign, nil
}

func max(a, b float64) float64 {
    if a > b {
        return a
    }
    return b
}

func maxInt(a, b int) int {
    if a > b {
        return a
    }
    return b
}

// -- Public Interface for Geometry Retrieval --

func (e *Engine) GetElementGeometry(layoutRoot *LayoutBox, selector string) (*schemas.ElementGeometry, error) {
    if layoutRoot == nil {
        return nil, fmt.Errorf("layout tree is nil")
    }

    domRoot := findDOMRoot(layoutRoot)
    if domRoot == nil {
        return nil, fmt.Errorf("could not find root DOM node")
    }

    targetNode, err := htmlquery.Query(domRoot, selector)
    if err != nil {
        return nil, fmt.Errorf("invalid XPath selector '%s': %w", selector, err)
    }
    if targetNode == nil {
        return nil, fmt.Errorf("element not found matching selector '%s'", selector)
    }

    box := findLayoutBoxForNode(layoutRoot, targetNode)
    if box == nil {
        return nil, fmt.Errorf("element '%s' found in DOM but not rendered (e.g., display: none)", selector)
    }

    if box.StyledNode != nil && !box.StyledNode.IsVisible() {
        return nil, fmt.Errorf("element '%s' is hidden (visibility, opacity, etc.)", selector)
    }

    return box.ToElementGeometry(), nil
}

func (b *LayoutBox) ToElementGeometry() *schemas.ElementGeometry {
    rect := b.Dimensions.BorderBox()
    transform := b.Dimensions.Transform

    x, y, width, height := rect.X, rect.Y, rect.Width, rect.Height

    topLeftX, topLeftY := x, y
    topRightX, topRightY := x+width, y
    bottomRightX, bottomRightY := x+width, y+height
    bottomLeftX, bottomLeftY := x, y+height

    tx1, ty1 := transform.Apply(topLeftX, topLeftY)
    tx2, ty2 := transform.Apply(topRightX, topRightY)
    tx3, ty3 := transform.Apply(bottomRightX, bottomRightY)
    tx4, ty4 := transform.Apply(bottomLeftX, bottomLeftY)

    vertices := []float64{
        tx1, ty1,
        tx2, ty2,
        tx3, ty3,
        tx4, ty4,
    }

    minX := math.Min(tx1, math.Min(tx2, math.Min(tx3, tx4)))
    maxX := math.Max(tx1, math.Max(tx2, math.Max(tx3, tx4)))
    minY := math.Min(ty1, math.Min(ty2, math.Min(ty3, ty4)))
    maxY := math.Max(ty1, math.Max(ty2, math.Max(ty3, ty4)))

    aabbWidth := maxX - minX
    aabbHeight := maxY - minY

    return &schemas.ElementGeometry{
        Vertices: vertices,
        Width:    int64(math.Round(aabbWidth)),
        Height:   int64(math.Round(aabbHeight)),
    }
}

func findDOMRoot(box *LayoutBox) *html.Node {
    if box == nil {
        return nil
    }

    rootBox := box
    for rootBox.ContainingBlock != nil {
        rootBox = rootBox.ContainingBlock
    }

    if rootBox.StyledNode != nil && rootBox.StyledNode.Node != nil {
        rootNode := rootBox.StyledNode.Node
        for rootNode.Parent != nil {
            rootNode = rootNode.Parent
        }
        return rootNode
    }
    return nil
}

func findLayoutBoxForNode(root *LayoutBox, target *html.Node) *LayoutBox {
    if root == nil {
        return nil
    }

    if root.StyledNode != nil && root.StyledNode.Node == target {
        return root
    }

    for _, child := range root.Children {
        if found := findLayoutBoxForNode(child, target); found != nil {
            return found
        }
    }

    return nil
}